---
sidebar_position: 6
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Solidity Primitive Data Types - Value Types

## Primitive Data Types Overview

In a high-level programming language, a primitive data type is the simplest building block for data. They are data types that cannot be reduced into a simpler form. Primary data types are the building blocks for other data types.

Usually, these at least include:

- certain types of number representations
- strings for character representation
- Booleans for true or false representation

### Value Types Defined

This section will cover **value types**.

A value type:

- is the actual value.
- stores its data directly on the memory it owns.
- **passes by value** aka, the variable's values are **copied** when they are used as function arguments or in assignments. These copies don't affect the original data.

These are different from **reference types**.

Reference types:

- [references](<https://en.wikipedia.org/wiki/Reference_(computer_science)>) data at another location, aka it [points](<https://en.wikipedia.org/wiki/Pointer_(computer_programming)>) to another spot.

We will cover reference types and memory in the following lessons.

### Structing Data in Context

Why are these important? To write a program, you must define the type of data you will store and manipulate. For example, will you hold numbers, words, a collections of these, or some custom data type etc.?

A significant part of understanding how to design and code programs centers around:

- understanding which types of data you'd want to manipulate.
- and how to manipulate that data.

Once our data is structured correctly, algorithms are used to manipulate the data. **Algorithms** are a series of instructions to solve a specific type of problem efficiently. It's worth noting that certain types of problems are best solved with particular data types and algorithms. The study of this is covered in a course on data structure and algorithms.

Furthermore, certain recurring business logic problems are best solved with repeatable patterns. These best practices are called **design patterns**, and their application to web3 development will be covered in the future.

### Booleans

[Booleans](https://en.wikipedia.org/wiki/Boolean_data_type) are a form of data with only two possible states: `true` or `false`. These are useful for control flow of a program.

Fun fact: Computers store and represent numerical data using [Boolean Math](https://www.youtube.com/watch?v=1GSjbWt0c9M).

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Booleans {
    // booleans - true or false
    bool public boo = true;
    bool public foo = false;
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class Booleans {
    // boleans - true or false
    let x = true;
    let y = false;
}
```

</TabItem>
</Tabs>

### Strings

Strings are a sequence of characters, either as a [literal constant](<https://en.wikipedia.org/wiki/Literal_(computer_programming)>) or as some kind of variable.

In both Solidity and JavaScript, strings are immtuable. The word `"Hello"` is fixed. If you change it to `"Hello World"` is a totally different word.

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Strings {
    bool public str1 = "Hello, World";
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class Strings {
  let str = "Hello, World";
}
```

</TabItem>
</Tabs>

### String escape characters

There are escape characters as well. Note the capital letter `N` is a stand in, and can represent any character as defined in the description.

With the exception of [hexadecimal represenation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_dates#hexadecimal_numbers), these are all the same in JavaScript.

[Hexcadecimal values](https://www.techtarget.com/whatis/definition/hexadecimal) are base-16 number systems running from 0-9 and A-F. You probably have seen them while using CSS.

| Syntax | Description                                                  |
| ------ | ------------------------------------------------------------ |
| \n     | Starts a new line.                                           |
| \\     | Backslash                                                    |
| \n     | Starts a new line.                                           |
| \'     | Single Quote                                                 |
| \"     | Double Quote                                                 |
| \b     | Backspace                                                    |
| \f     | Form Feed                                                    |
| \r     | carriage return                                              |
| \t     | tab                                                          |
| \v     | vertical tab                                                 |
| \xNN   | Represents hexadecimal values and inserts appropriate bytes. |
| \uNNNN | Represents Unicode value and inserts UTF-8 sequence.         |

### Integers

Integers are ...

Negative numbers are allowed for int types.
Like uint, different ranges are available from int8 to int256

int256 ranges from -2 ** 255 to 2 ** 255 - 1
int128 ranges from -2 ** 127 to 2 ** 127 - 1

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Integers {
    // integers
    // Specify variables from 8 bytes to 256 bytes
    int8 public i8 = -1;
    int public i256 = 1234;
    int public i = -1234; // int is an alias for int256
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class Numbers {
  // Add code for primitive values
  // JavaScript only has a Number Type
  // No memory specfic number types
}
```

</TabItem>
</Tabs>

### Unsigned Integers

uint stands for unsigned integer, meaning non negative integers
different sizes are available
uint8 ranges from 0 to 2 ** 8 - 1
uint16 ranges from 0 to 2 ** 16 - 1
...
uint256 ranges from 0 to 2 \*\* 256 - 1

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract UnsignedIntegers {
    // These are unsigned, meaning no negatives (-) value.
    // So they are only positive (+)
    uint8 public u8 = 1;
    uint public u256 = 456;
    uint public u = 123; // uint is short hand for uint256
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class Numbers {
  // Add code for primitive values
  // JavaScript only has one  Number Type
  // no concept of unsigned integer
  // Add BigInt type - numbers of arbitray size
}
```

</TabItem>
</Tabs>

## Size, integers and unsigned integers

The table below shows the built-in integer types in Solidity.

| Length        | Signed | Unsigned |
| ------------- | ------ | -------- |
| 8-bit         | int8   | uint8    |
| 16-bit        | int16  | uint16   |
| 32-bit        | int32  | uint32   |
| 64-bit        | int64  | uint64   |
| 128-bit       | int128 | uint128  |
| 256-bit       | int256 | uint256  |
| 256-bit alias | int    | uint     |

## Maximum and Minimum Numbers

Maximum numbers and minimum numbers

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract MinMax {
    // minimum and maximum of int
    // max int = ENTER NUMBER
    // min int = ENTER NUMBER
    int public minInt = type(int).min;
    int public maxInt = type(int).max;

}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class MinMax {
  let x = Number.MIN_VALUE; // returns SMALLEST number in JavaScript -> 5e-324
  let x = Number.MAX_VALUE; // returns LARGEST number in JavaScript -> 1.7976931348623157e+308
}
```

</TabItem>
</Tabs>

## Bytes

In Solidity, the data type byte represent a sequence of bytes.
Solidity presents two type of bytes types :

- fixed-sized byte arrays
- dynamically-sized byte arrays.

The term bytes in Solidity represents a dynamic array of bytes.
Itâ€™s a shorthand for byte[].

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract MinMax {
    // bytes
    bytes1 a = 0xb5; //  [10110101]
    bytes1 b = 0x56; //  [01010110]

}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class ArrayBuffer {
    // create a buffer of 8 bytes
    const buffer = new ArrayBuffer(8);
    const view = new Int32Array(buffer);

    // Learn more about ArrayBuffers here:
    // https://javascript.info/arraybuffer-binary-arrays
}
```

</TabItem>
</Tabs>

## Address

Addresses are a special data type specific to Solidity.

**ADD WHY**

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Addresses {
    // Specific to Solidity: addresses
    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;

}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class NoAddresses {
  // JavaScript doesn't have a concept of Addresses!
  // ðŸ¤·
}
```

</TabItem>
</Tabs>

## Default assignment

Unassigned values in Solidity are assigned default values.

A note on default values ...

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Primitives {
    //...
    // Default values
    bool public defaultBoo; // false
    uint public defaultUint; // 0
    int public defaultInt; // 0
    address public defaultAddr; // 0x0000000000000000000000000000000000000000
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class VariablesOverview {
  // add code for default assignment of values
}
```

</TabItem>
</Tabs>

### There Are No Decimals in Solidity

Notice that there are no decimals in Solidity! In computing, these are called **Fixed Point Numbers**.

The reason behind this is because of the limits of fixed point math on the EVM.

**ADD WHY**

#### Doing Decimal Math in Solidity

So, how do we calculate decimals and fractional numbers. We will cover doing fixed point math more in depth in a future post.
For now, here is a brief summary.

<Tabs>
<TabItem value="sol" label="Solidity">

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract DecimalMath {
    //...
    // add work arounds
    // openzeppelin contracts?
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
class DecimalMath {
  // easier for JavaScript
  // add code
}
```

</TabItem>
</Tabs>
