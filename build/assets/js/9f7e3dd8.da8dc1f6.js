"use strict";(self.webpackChunkbuilders_eth=self.webpackChunkbuilders_eth||[]).push([[4984],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(n),d=i,g=m["".concat(s,".").concat(d)]||m[d]||u[d]||a;return n?r.createElement(g,o(o({ref:t},p),{},{components:n})):r.createElement(g,o({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4029:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return v},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),o=["components"],l={sidebar_position:7},s="Pragma: Choosing the Right Compiler",c={unversionedId:"solidity-101/language-building-blocks/Solidity-File-Overview/Pragma",id:"solidity-101/language-building-blocks/Solidity-File-Overview/Pragma",title:"Pragma: Choosing the Right Compiler",description:"Let's examine our HelloWorld.sol contract to focus on pragma.",source:"@site/docs/solidity-101/2-language-building-blocks/1-Solidity-File-Overview/7-Pragma.mdx",sourceDirName:"solidity-101/2-language-building-blocks/1-Solidity-File-Overview",slug:"/solidity-101/language-building-blocks/Solidity-File-Overview/Pragma",permalink:"/docs/solidity-101/language-building-blocks/Solidity-File-Overview/Pragma",draft:!1,editUrl:"https://github.com/tesla809/BuildersETH/issues/docs/solidity-101/2-language-building-blocks/1-Solidity-File-Overview/7-Pragma.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Hello, World!",permalink:"/docs/solidity-101/language-building-blocks/Solidity-File-Overview/hello-world"},next:{title:"Licences",permalink:"/docs/solidity-101/language-building-blocks/Solidity-File-Overview/Licences"}},p={},u=[{value:"What is a Compiler",id:"what-is-a-compiler",level:3},{value:"Semver targeting",id:"semver-targeting",level:2},{value:"Defining Pragma",id:"defining-pragma",level:2},{value:"Pragma Best Practice",id:"pragma-best-practice",level:2}],m=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)}},d=m("Tabs"),g=m("TabItem"),h={toc:u};function v(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pragma-choosing-the-right-compiler"},"Pragma: Choosing the Right Compiler"),(0,a.kt)("p",null,"Let's examine our ",(0,a.kt)("inlineCode",{parentName:"p"},"HelloWorld.sol")," contract to focus on ",(0,a.kt)("inlineCode",{parentName:"p"},"pragma"),"."),(0,a.kt)(d,{mdxType:"Tabs"},(0,a.kt)(g,{value:"sol",label:"HelloWorld.sol",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\n// compiler version must be greater than or equal to 0.8.13 and less than 0.9.0\npragma solidity ^0.8.13;\n\ncontract HelloWorld {\n    string public greetings = "Hello World!";\n}\n')))),(0,a.kt)("p",null,"As mentioned before, pragma lets the Solidity Compiler know which version of Solidity you are using. For this course, we will focus on Solidity ",(0,a.kt)("inlineCode",{parentName:"p"},"0.8.13"),"."),(0,a.kt)("p",null,"Like all programming languages, Solidity is an evolving language. Over time, updates, bug fixes, and improvements make the languages easier and safer to use."),(0,a.kt)("p",null,"It is essential to specify the version of the language used. The language is compiled into EVM bytecode, then run on the Ethereum Virtual Machine. Knowing which version to use lets the compiler know how to translate the code."),(0,a.kt)("h3",{id:"what-is-a-compiler"},"What is a Compiler"),(0,a.kt)("p",null,"A compiler is software that translates human-readable code into a lower-level form, usually machine-readable code. Compilers are helpful because they allow for high-level languages with valuable additions to make development easier."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma solidity >=0.4.16 <0.9.0;\n")),(0,a.kt)("h2",{id:"semver-targeting"},"Semver targeting"),(0,a.kt)("p",null,"Such a broad scope for the compiler can result in errors and uncaught bugs since such a wide range eliminates the ability to use the correct compiler predictable across development environments. For example, one developer may have ",(0,a.kt)("inlineCode",{parentName:"p"},"0.8.10"),", while another may have ",(0,a.kt)("inlineCode",{parentName:"p"},"0.5.5"),"."),(0,a.kt)("p",null,"We can specify the choose the version of the language using ",(0,a.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/introduction-semantic-versioning/"},"semantic versioning (semver)"),"."),(0,a.kt)("p",null,"In ",(0,a.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/introduction-semantic-versioning/#:~:text=Semantic%20Versioning%20is%20a%203,and%20minor%20versions%20to%20zero."},"semantic versioning")," (semver):"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"major versions: ",(0,a.kt)("strong",{parentName:"li"},"x")," -> ",(0,a.kt)("strong",{parentName:"li"},"x"),".yy.zz"),(0,a.kt)("li",{parentName:"ul"},"minor versions: ",(0,a.kt)("strong",{parentName:"li"},"y")," -> x.",(0,a.kt)("strong",{parentName:"li"},"yy"),".zz"),(0,a.kt)("li",{parentName:"ul"},"patches: ",(0,a.kt)("strong",{parentName:"li"},"z")," -> x.yy.",(0,a.kt)("strong",{parentName:"li"},"zz"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Major:")," break the API and are not backward compatible.",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("strong",{parentName:"p"},"Minor:")," update the API and are backward compatible.",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("strong",{parentName:"p"},"Patches:")," bug fixes."),(0,a.kt)("h2",{id:"defining-pragma"},"Defining Pragma"),(0,a.kt)("p",null,"Using Semver and ",(0,a.kt)("inlineCode",{parentName:"p"},"pragma"),", we can choose the correct compiler version. Solidity follows the semver syntax used by ",(0,a.kt)("a",{parentName:"p",href:"https://docs.npmjs.com/cli/v6/using-npm/semver"},"npm"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma solidity >=0.8.0 <0.9.0;\n// Anything between 0.8.0 to 0.9.0\n// where 0.9.0 is not included.\n\npragma solidity ^0.8.5;\n// same as above\n// Anything above 0.8.0 to 0.9.0\n// where 0.9.0 is not included.\n\npragma solidity ~0.8.5;\n// accept patches from 0.8.5 and up\n// patches are 0.00.xx\n\npragma solidity 0.8.8;\n// ONLY version 0.8.8\n")),(0,a.kt)("h2",{id:"pragma-best-practice"},"Pragma Best Practice"),(0,a.kt)("p",null,"When in doubt, choose one relatively recent version of Solidity only in the current major version. This is for two reasons."),(0,a.kt)("p",null,"First, known bugs and errors from previous versions have been addressed, leading to safer code."),(0,a.kt)("p",null,"Second, you will have fewer errors. The compiler is pretty strict about errors. Due to language updates, an older version of Solidity will throw more errors than the recent version."))}v.isMDXComponent=!0}}]);